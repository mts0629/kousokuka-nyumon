# キャッシュメモリ

## 2次元配列の総和

2次元配列の総和を計算する。
このとき、配列の各要素に対するアクセスの方向（順序）によってキャッシュミスの発生頻度が変わり、性能に影響する可能性がある。

- 垂直方向（メモリアドレス非連続）

    アドレス空間上の離れた位置にアクセスするため、キャッシュミスが頻発しやすく、性能が劣化しやすい。

    ```cpp
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            sum += a[j][i];
        }
    }
    ```

- 水平方向（メモリアドレス連続）

    アドレス空間上の連続位置にアクセスするため、キャッシュミスの頻度が垂直方向よりも減り、性能が劣化しにくい。

    ```cpp
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            sum += a[i][j];
        }
    }
    ```

アクセス順序により性能が大きく変動する。

```sh
./bin/vertical
sum = 36028797018963968.000000

elapsed time =       0.7000420 sec

./bin/horizontal
sum = 36028797018963968.000000

elapsed time =       0.0698980 sec
```

## 2次元配列への書き込み

参照と同様に、2次元配列への書き込み動作もアクセス方向により性能が変動する。

```sh
./bin/horizontal
elapsed time =       0.0245710 sec

./bin/vertical
elapsed time =       0.8166950 sec
```

## サブブロックへ分割

対象の二次元配列を小サイズのサブブロックへ分割して処理する（ストリップマイニング）と、キャッシュラインに乗っているデータを再度参照でき、キャッシュヒットミスの回数を削減できる。

最適な分割単位は、キャッシュメモリの容量やキャッシュラインのサイズなどによって変わる。
ここでは 16x16 の単位に分割している。

```cpp
for (int jOffset = 0; jOffset < N; jOffset += 16) {
    for (int iOffset = 0; iOffset < N; iOffset += 16) {
        for (int i = iOffset; i < (iOffset + 16); i++) {
            for (int j = jOffset; j < (jOffset + 16); j++) {
                sum += a[j][i];
            }
        }
    }
}
```

最内ループが垂直方向への参照となっているが、キャッシュを参照できているために速度が上がっている。

```sh
./bin/subblock
sum = 36028797018963968.000000

elapsed time =       0.0716790 sec
```
